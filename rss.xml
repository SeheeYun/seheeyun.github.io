<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Sehee Blog]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://seheeyun.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 21 Jan 2022 15:56:33 GMT</lastBuildDate><item><title><![CDATA[TypeScrpit + OOP]]></title><description><![CDATA[TypeScript 타입스크립트는 Microsoft에서 개발하고 유지/관리하는 오픈 소스 프로젝트로서, 자바스크립트로 컴파일되는 superset of JavaScript…]]></description><link>https://seheeyun.github.io/TypeScrpit + OOP/</link><guid isPermaLink="false">https://seheeyun.github.io/TypeScrpit + OOP/</guid><pubDate>Fri, 21 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;TypeScript&lt;/h3&gt;
&lt;p&gt;타입스크립트는 Microsoft에서 개발하고 유지/관리하는 오픈 소스 프로젝트로서, 자바스크립트로 컴파일되는 superset of JavaScript 이기 때문에 자바스크립트가 동작하는 모든 곳에서 대체하여 사용할 수 있는 언어이다.&lt;/p&gt;
&lt;p&gt;자바스크립트는 C나 Java와 같은 C-family 언어와는 구별되는 아래와 같은 특성이 있는데&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely typed) 언어
- Prototype-based Object Oriented Language&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;자바스크립트는 런타임에 실시간으로 타입이 결정되는 동적 언어이기때문에 런타임 환경에서 예상치 못한 에러가 발생할 수 있다. 타입스크립트는 정적 타이핑을 지원하고 이는 사전에 타입을 명시적으로 선언하도록하며 잘못된 값을 할당할 경우 컴파일러를 통해 대부분의 에러를 확인 할 수 있게한다.&lt;/p&gt;
&lt;p&gt;또한 타입스크립트는 interface, generic 등을 지원하여 클래스를 베이스로하는 다른 언어들과같이 더욱 강력한 객체 지향 프로그래밍을 가능하게 한다.&lt;/p&gt;
&lt;h3&gt;객체 지향 프로그래밍(Object-Oriented Programming)&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;객체 지향 프로그래밍은 컴퓨터 프로그래밍의 패러다임 중 하나로, 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 &amp;quot;객체&amp;quot;들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
프로그램을 유연하고 변경이 쉽게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점이 있다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Encapsulation 캡슐화&lt;/h4&gt;
&lt;p&gt;서로 관련있는 데이터와 메서드를 한 오브젝트안에 담아두고 외부에서 보일 필요가 없는 데이터를 잘 숨겨놓음으로써 캡슐화 하는것.&lt;/p&gt;
&lt;p&gt;외부에서 내부의 상태를 직접 조작하게 하는 것은 위험하기때문에 private 키워드와 같은 접근제어자로 은닉화해서 외부에서 접근 할 수 없도록 해준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public&lt;br/&gt;
클래스로 만들어준 오브젝트에는 클래스의 멤버변수들이 인스턴스화하여 생성되어있다. 아무런 키워드가 없다면 public 으로 외부에서 바로 접근이 가능하다.&lt;/li&gt;
&lt;li&gt;private&lt;br/&gt;
클래스의 내부에서만 사용되며 외부로 노출되지 않는다.&lt;/li&gt;
&lt;li&gt;protected&lt;br/&gt;
외부에서 접근할 수 없고, 자신을 상속하는 자식 클래스에서만 접근이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;생성자 함수(constructor) 자체를 private으로 만들면 클래스를 생성자 함수로 생성할 수 없어지기때문에 메서드를 static 으로 제공해서 클래스에 메서드만 사용해서 오브젝트를 생성하게 할 수 도있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CoffeeMachineImple&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 안됨&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;makeMachine&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;coffeeBeans&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; CoffeeMachineImple &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CoffeeMachineImple&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;coffeeBeans&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; machine &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; CoffeeMachineImple&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;makeMachine&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;static&lt;br/&gt;
클래스의 멤버변수는 클래스를 인스턴스화 했을 때 생성, 바뀌지 않는 값이되고 해당 클래스로 생성한 모든 인스턴스마다 저 값이 중복적으로 생성되기때문에 메모리 낭비가 된다. 이럴 경우 변수앞에 &lt;strong&gt;static을 붙여줘서 클래스 레벨로 지정&lt;/strong&gt;해 줄 수 있다. static을 붙이지 않으면 인스턴스 레벨이다.&lt;/p&gt;
&lt;p&gt;위와 같이 클래스 레벨로 만든경우 이 클래스로 생성된 인스턴스가 아닌 클래스 자체의 데이터이기 때문에 this.가 아닌 클래스 이름 자체를 지정해서 접근한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Abstraction 추상화&lt;/h4&gt;
&lt;p&gt;내부의 복잡한 기능은 외부에 보이지않게 하고 외부에서 보이는 인터페이스(함수)만을 통해 내부 기능을 이해하지 않아도 사용할 수 있도록 하는 것.&lt;/p&gt;
&lt;p&gt;캡슐화와 달리 ‘건드리면 안되는 것은 숨기고, 건드려도 되는 것은 노출한다’가 아니라, 복잡한 로직들을 외부에서 어떻게 사용하게 할것인가를 고민하는 단계로 &lt;strong&gt;객체들에 공통적으로 존재하는 메소드와 속성들을 뽑아서(추출), 인터페이스나 다른 부모 클래스의 형태로 새롭게 만드는 것&lt;/strong&gt;을 의미한다.&lt;/p&gt;
&lt;p&gt;추상화의 가장 큰 장점은 같은 인터페이스를 구현하는 클래스들은 각자 저마다 다른 방식을 구현하더라도, 사용자는 인터페이스에 정의된 함수 하나로 단순하게 기능을 사용 할 수 있는 것이다.&lt;/p&gt;
&lt;h4&gt;Inheritance 상속&lt;/h4&gt;
&lt;p&gt;상속을 이용해서 클래스를 &lt;strong&gt;재사용&lt;/strong&gt; 할 수 있다.&lt;/p&gt;
&lt;p&gt;상속하는 자식 클래스는 부모 클래스라고 말할 수 있는데 예로 animal에 상속을 사용해서 만든 강아지, 고양이는 animal이다. IS-A, is a 관계라고도 말한다.&lt;/p&gt;
&lt;p&gt;상속을 하게 되면 기본적으로는 부모 클래스에서 가지고 있는 모든 멤버 변수(속성), 함수(행동) 들에 대해서 자식 클래스가 모두 다 가지게 되고, 자식 클래스의 this로 접근 할 수 있다.&lt;/p&gt;
&lt;p&gt;단, 생성자나 함수에 한해서만 자식 클래스가 상속을 하면서 변경을 할 수 있게 되고(&lt;strong&gt;method overriding&lt;/strong&gt;) 이때 &lt;strong&gt;자식에서 재정의된 함수를 호출하고 싶다면 this&lt;/strong&gt;를, &lt;strong&gt;기존의 부모 클래스에서 작성된 함수(또는 생성자)를 호출하고 싶다면 super&lt;/strong&gt;를 써야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;super&lt;br/&gt;
super 키워드를 사용하면 부모 클래스에 접근 할 수 있다. 자식 클래스에서 생성자 함수를 사용하고싶다면 생성자 함수 내부에서 super를 호출해야한다.
그리고 부모클래스의 생성자 함수에 필요한 인자가 있다면 자식 클래스에서도 인자를 받아서 super의 인자로 부모클래스에 전달해주어야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;타입스크립트는 &lt;strong&gt;상속으로 서로다른 두 클래스를 상속하는 것(합치는 것)이 불가능하며, 부모 클래스의 행동을 수정하게 될 경우 상속하는 모든 자식 클래스에도 영향을 미치는 단점이 있기 때문에 상속의 깊이가 깊어질수록 관계가 복잡해진다.&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;Polymorphism 다형성&lt;/h4&gt;
&lt;p&gt;하나의 인터페이스나 부모 클래스를 상속한 자식 클래스들은 인터페이스와 부모 클래스에 있는 함수들을 각자 다른 방식으로 다양한 형태로 구성할 수 있다는 것이다.&lt;/p&gt;
&lt;p&gt;다르게 말하면 부모 클래스를 상속해서 만들어진 자식 클래스들의 다양한 형태를 신경쓸 필요없이 공통된 (부모 클래스의)함수를 호출할 수 있는 것.&lt;/p&gt;
&lt;h4&gt;Composition&lt;/h4&gt;
&lt;p&gt;위에서 설명한 상속의 단점들을 고려하여 확장성있고 재사용성있는 코드를 작성해야할 때, Composition을 사용한다.&lt;/p&gt;
&lt;p&gt;생성자 함수의 인자에 타입을 지정하여 &lt;strong&gt;의존성 주입(Defendency Injection)&lt;/strong&gt;을 해준다. 이때, &lt;strong&gt;클래스끼리의 의사소통은 클래스 자신을 직접적으로 노출하지않고 interface를 통해서 의사소통하는 것이 디커플링의 원칙&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;인터페이스로 인자의 타입을 지정해준 뒤 그 인터페이스를 구현하는 다양한 클래스를 만듦으로써 인자로 그 클래스들을 전달해주면 되니까 상속을 전혀 사용하지않고 다양한 형태의 오브젝트를 원하는 대로 조립해서 만들 수 있게된다.&lt;/p&gt;
&lt;h4&gt;interface&lt;/h4&gt;
&lt;p&gt;인터페이스는 일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용할 수 있다. 인터페이스는 여러가지 타입을 갖는 프로퍼티로 이루어진 새로운 타입을 정의하는 것과 유사하다. &lt;strong&gt;인터페이스는 자신을 구현하는 클래스에 인터페이스에 선언된 프로퍼티 또는 메소드의 구현을 강제하여 일관성을 유지&lt;/strong&gt;할 수 있게한다.&lt;/p&gt;
&lt;p&gt;프로퍼티와 메소드를 가질 수 있다는 점에서 클래스와 유사하나 직접 인스턴스를 생성할 수 없고 모든 메소드는 추상 메소드이다.&lt;/p&gt;
&lt;p&gt;인터페이스는 extends 키워드를 사용하여 확장할 수 있다. 인터페이스 또는 클래스를 상속받거나 복수의 인터페이스를 상속받을 수도 있다.
클래스를 상속했을 떈, 클래스의 모든 멤버(public, protected, private)가 상속되지만 구현까지 상속하지는 않는다.&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://poiemaweb.com/typescript-introduction&quot;&gt;https://poiemaweb.com/typescript-introduction&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://academy.dream-coding.com/&quot;&gt;https://academy.dream-coding.com/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React State의 불변성]]></title><description><![CDATA[State와 Props state
컴포넌트 UI를 위한 데이터를 보관하는 오브젝트로, 이 state가 업데이트 되면 render 함수가 호출 된다. 컴포넌트 안에서 정의된다. props
state…]]></description><link>https://seheeyun.github.io/React State의 불변성/</link><guid isPermaLink="false">https://seheeyun.github.io/React State의 불변성/</guid><pubDate>Thu, 30 Sep 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;State와 Props&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;&lt;br/&gt;
컴포넌트 UI를 위한 데이터를 보관하는 오브젝트로, 이 state가 업데이트 되면 render 함수가 호출 된다. 컴포넌트 안에서 정의된다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;props&lt;/strong&gt;&lt;br/&gt;
state와 다르게 컴포넌트 외부에서 데이터를 받아온다. 외부의 데이터에따라 UI가 변경될 수 있고 재사용성을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;state와 props 객체안에 key: value는 읽기전용으로 직접 수정하면 안된다. state는 setState() 함수를 이용해서 업데이트 해야 한다.&lt;/p&gt;
&lt;h3&gt;State의 불변성&lt;/h3&gt;
&lt;p&gt;리액트에서는 state 객체의 값을 직접적으로 수정하면 안된다. 이것을 불변성 유지라고 하는데, &lt;code class=&quot;language-text&quot;&gt;push, splice, unshift, pop&lt;/code&gt;과 같은 내장함수는 배열 자체를 직접 수정하게 되므로 적합하지 않다. 대신, 기존의 배열에 기반하여 새 배열을 만들어내는 &lt;code class=&quot;language-text&quot;&gt;concat, slice, map, filter&lt;/code&gt;과 같은 함수를 사용해야 한다.&lt;/p&gt;
&lt;p&gt;리액트는 컴포넌트의 state가 변경되면 함수를 호출해 컴포넌트를 리렌더링하고 상위의 컴포넌트가 리렌더링되면 하위의 모든 컴포넌트도 리렌더링되는데, Virtual DOM tree와 실제 DOM tree를 비교해서 실질적으로 변화가있는 부분만 업데이트한다.&lt;/p&gt;
&lt;p&gt;이 과정에서 렌더링 함수가 불필요하게 호출 되는 것을 막고자 PureComponent를 적용해 줄 수 있다. PureComponent는 props와 state에 대하여 얕은 비교를 수행하고, 변화가 없다면 함수를 호출하지않는다.&lt;/p&gt;
&lt;p&gt;불변성 유지가 중요한 이유는 이 &lt;strong&gt;얕은 비교는 각 오브젝트 안에 데이터까진 확인하지않고 오브젝트의 참조만을 비교&lt;/strong&gt;하는데,&lt;br/&gt;
state의 데이터를 직접적으로 수정하게 될 경우 데이터의 값은 바뀌지만 참조값은 바뀌지않기 때문에 state가 변화하지않았다고 판단하여 리렌더링되지않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;불변성 유지를 위해 위와같이 새 배열을 만드는 메서드를 사용하거나 얕은 복사를 수행하는 Object.assign, spread syntax를 사용&lt;/strong&gt;한다.&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://velopert.com/3636&quot;&gt;https://velopert.com/3636&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://academy.dream-coding.com/&quot;&gt;https://academy.dream-coding.com/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://reactjs.org/&quot;&gt;https://reactjs.org/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Hook과 클로저]]></title><description><![CDATA[useEffect를 컴포넌트 안에서 불러내는 이유는 무엇일까요? useEffect를 컴포넌트 내부에 둠으로써 effect를 통해 count state 변수(또는 그 어떤 prop…]]></description><link>https://seheeyun.github.io/React Hook과 클로저/</link><guid isPermaLink="false">https://seheeyun.github.io/React Hook과 클로저/</guid><pubDate>Wed, 15 Sep 2021 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;useEffect를 컴포넌트 안에서 불러내는 이유는 무엇일까요?&lt;/strong&gt; useEffect를 컴포넌트 내부에 둠으로써 effect를 통해 count state 변수(또는 그 어떤 prop에도)에 접근할 수 있게 됩니다. 함수 범위 안에 존재하기 때문에 특별한 API 없이도 값을 얻을 수 있는 것입니다. Hook은 자바스크립트의 &lt;strong&gt;클로저&lt;/strong&gt;를 이용하여 리액트에 한정된 API를 고안하는 것보다 자바스크립트가 이미 가지고 있는 방법을 이용하여 문제를 해결합니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;React 공식 문서를 보고있는데 계속 클로저가 언급된다. 알고보니,&lt;/p&gt;
&lt;p&gt;함수형 컴포넌트는 리액트 컴포넌트를 리턴하는 함수이고, 필요할 때마다 다시 함수를 호출하여 렌더링을 한다. 함수형 컴포넌트의 상태관리를 하기 위해선 &lt;strong&gt;함수가 다시 실행됐을 때의 이전 상태를 기억하고 있어야하고, react hooks는 이를 위해 JS의 클로저를 활용&lt;/strong&gt;한 것이다.&lt;/p&gt;
&lt;p&gt;클로저란?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;전역변수를 사용하지않고 어떤 변수의 값을 외부에 개입을 차단, 은닉해서 사용할수있는 함수&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;클로저는 내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 실행 컨텍스트가 반환되어도(실행 컨텍스트 스택에서 사라진다는 말), &lt;strong&gt;외부함수 실행 컨텍스트 내의 활성 객체(Activation object)(변수, 함수 선언 등의 정보를 가지고 있다)는 내부함수에 의해 참조되는 한 유효하여 내부함수가 스코프 체인을 통해 참조할 수 있는 것&lt;/strong&gt;을 의미한다.&lt;/p&gt;
&lt;p&gt;React hook에서는 useState를 통해 생성한 상태를 접근하고 유지하기 위해서 useState 바깥쪽에 state를 저장한다고한다.&lt;/p&gt;
&lt;p&gt;클로저의 개념을 공부할 때 체감으로 다가오는 예시가 없어서 잘 이해가 되지않았었는데 아주 가까이에서 사용되고있었다. 소름&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://hewonjeong.github.io/deep-dive-how-do-react-hooks-really-work-ko/&quot;&gt;https://hewonjeong.github.io/deep-dive-how-do-react-hooks-really-work-ko/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://yeoulcoding.tistory.com/149#recentEntries&quot;&gt;https://yeoulcoding.tistory.com/149#recentEntries&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://velog.io/@ggong/useState-Hook%EA%B3%BC-%ED%81%B4%EB%A1%9C%EC%A0%80&quot;&gt;https://velog.io/@ggong/useState-Hook과-클로저&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://poiemaweb.com/js-closure&quot;&gt;https://poiemaweb.com/js-closure&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript의 This]]></title><description><![CDATA[다른 언어들에서 는 자기자신, 생성된 오브젝트인 자신을 가리키는 것인데 자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 객체가 동적으로 결정된다. 다시 말해, 함수를 선언할 때 this…]]></description><link>https://seheeyun.github.io/JavaScript의 This/</link><guid isPermaLink="false">https://seheeyun.github.io/JavaScript의 This/</guid><pubDate>Thu, 26 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;다른 언어들에서 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;는 자기자신, 생성된 오브젝트인 자신을 가리키는 것인데 자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 객체가 동적으로 결정된다.&lt;br/&gt; 다시 말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 &lt;strong&gt;함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정&lt;/strong&gt;된다.&lt;/p&gt;
&lt;h3&gt;전역 객체와 let&lt;/h3&gt;
&lt;p&gt;전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window 객체, Server-side(Node.js)에서는 global 객체를 의미한다. 전역 코드에서 선언된 함수나 var 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const, let&lt;/strong&gt; 키워드로 선언된 변수를 전역 변수로 사용하는 경우, &lt;strong&gt;let 전역 변수는 전역 객체의 프로퍼티가 아니다.&lt;/strong&gt; 즉, &lt;code class=&quot;language-text&quot;&gt;window.foo&lt;/code&gt;와 같이 접근할 수 없다. &lt;strong&gt;let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;this 바인딩&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;increase&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; counter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
counter&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;increase&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Counter&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; caller &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; counter&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;increase
&lt;span class=&quot;token function&quot;&gt;caller&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 코드가 있다고 가정했을 때, counter.increase()는 Counter를 출력하고 caller()는 undefined를 출력한다.&lt;/p&gt;
&lt;p&gt;변수 counter는 인스턴스화 된 Counter이기때문에 increase()를 호출한 this는 Counter이고 그래서 this는 Counter를 가르킨다.&lt;/p&gt;
&lt;p&gt;변수 caller는 couter에 있는 increase라는 함수 자체를 가르킨다는 것이다.
caller는 this를 출력하는 함수 객체를 담고있는데, 그 함수를 담고있는 caller라는 변수는 const로 선언했고 전역 객체에 등록되지 않는다.&lt;/p&gt;
&lt;p&gt;그 말은 this를 출력하는 함수를 caller()로 실행해도 caller()를 호출하는 this가 아무것도 아니기때문에 undefined로 출력되는 것이다.&lt;/p&gt;
&lt;p&gt;이와 같이 동적으로 변하는 this의 값을 고정시키기위해 바인딩을 해준다.&lt;/p&gt;
&lt;h3&gt;Arrow Function&lt;/h3&gt;
&lt;p&gt;bind() 함수를 사용하지 않고 class 내부에서 함수를 arrow function으로 선언해주면 this를 바인드 할 수 있다.
arrow function을 사용하면 다른 클래스 언어들처럼 선언될 당시의 this context를 유지한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;화살표 함수는 자신의 this가 없습니다. 대신 화살표 함수를 둘러싸는 렉시컬 범위(lexical scope)의 this가 사용됩니다; 화살표 함수는 일반 변수 조회 규칙(normal variable lookup rules)을 따릅니다. 때문에 현재 범위에서 존재하지 않는 this를 찾을 때, 화살표 함수는 바로 바깥 범위에서 this를 찾는것으로 검색을 끝내게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://academy.dream-coding.com/&quot;&gt;https://academy.dream-coding.com/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://poiemaweb.com/js-this&quot;&gt;https://poiemaweb.com/js-this&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript의 런타임 환경]]></title><description><![CDATA[…]]></description><link>https://seheeyun.github.io/JavaScript의 런타임 환경/</link><guid isPermaLink="false">https://seheeyun.github.io/JavaScript의 런타임 환경/</guid><pubDate>Sat, 07 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;프로세스와 스레드&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;프로세스&lt;/strong&gt;&lt;br/&gt;
독립적인 메모리 공간을 할당받아 실행되고 있는 프로그램. 운영체제의 관점에서 최소 작업 단위이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;스레드&lt;/strong&gt;&lt;br/&gt;
스레드는 프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로로서 각각 저마다 수행해야하는 업무를 가지고있다. 각각 자신들만의 &lt;strong&gt;수행해야하는 함수의 호출을 기억해야하기 때문에&lt;/strong&gt; 프로세스가 할당받은 메모리 공간 내에서 스레드마다 &lt;strong&gt;Stack 영역의 메모리 공간을 따로 할당&lt;/strong&gt;받는다. 나머지 &lt;strong&gt;Code/Data/Heap 영역의 메모리 공간은 공유&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 같은 구조로 한 프로세스에서 오류가 발생하면 해당 프로세스만 죽게되지만, 스레드는 메모리 영역을 공유하므로 하나의 스레드에서 오류가 발생하면 같은 프로세스 내의 다른 스레드 모두 죽게된다.&lt;/p&gt;
&lt;p&gt;스레드는 기본 구조 자체가 메모리를 공유하는 구조이기 때문에 다른 스레드와 정보 공유가 쉽다. 때문에 멀티태스킹보다 &lt;strong&gt;멀티스레딩이 자원을 아낄 수 있게 된다.&lt;/strong&gt; 다만 서로 다른 스레드가 데이터와 힙 영역을 공유하면서 문제가 발생할 수 있고 이에대해 프로그래머가 직접 동기화 문제에 대응할 수 있어야 한다.&lt;/p&gt;
&lt;h3&gt;JavaScript 엔진의 이해&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://joshua1988.github.io/images/posts/web/translation/how-js-works/js-engine-structure.png&quot; alt=&quot;자바스크립트 엔진 구조&quot;&gt;
자바스크립트 엔진은 위와같이 크게 &lt;code class=&quot;language-text&quot;&gt;Memory Heap&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;Call Stack&lt;/code&gt;으로 나누어져있다.&lt;br/&gt;
&lt;a href=&quot;https://velog.io/@hidaehyunlee/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90&quot;&gt;참고1&lt;/a&gt; &lt;a href=&quot;https://curryyou.tistory.com/276&quot;&gt;참고2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트는 멀티스레딩이아닌 싱글 스레드 언어이다. 하지만 자바스크립트가 동작하는 브라우저는 여러개의 스레드를 가지고있고 이 브라우저가 제공하는 웹 APIs(fetch, setTimeout, eventListener 등)들을 이용하게 되면 멀티스레딩이 가능하다.&lt;/p&gt;
&lt;h3&gt;브라우저 런타임 환경의 이해&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://joshua1988.github.io/images/posts/web/translation/how-js-works/js-engine-runtime.png&quot; alt=&quot;자바스크립트 런타임 환경 구조&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Call Stack&lt;/strong&gt;&lt;br/&gt;
함수를 호출하게 되면 이 콜 스택에 함수 실행 컨텍스트가 쌓인다. 실행되고 나면 콜 스택에서 사라진다.
맨 위에 항목을 추가하는 push, 맨 위의 항목을 떼어내는 pop을 이용한 후입 선출(LIFO, Last-In First-Out)의 구조를 가진다.&lt;br/&gt;
자바스크립트는 한개의 콜 스택을 가지고있기때문에 &lt;strong&gt;하나의 함수가 실행되면 다른 일을 수행 할 수 없고 이 함수는 끝날 때까지 보장된다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web APIs&lt;/strong&gt;&lt;br/&gt;
함수 안에서 web api를 사용하게되면 자바스크립트 엔진과 &lt;strong&gt;병렬적으로 실행&lt;/strong&gt;되고 등록한 콜백을 task queue에 집어넣는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Task Queue&lt;/strong&gt;&lt;br/&gt;
선입 선출(FIFO, First In First Out)의 구조를 가진다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Event Loop&lt;/strong&gt;&lt;br/&gt;
빙글 빙글 돌면서 콜 스택과 태스크 큐를 관찰한다. 콜 스택에 쌓여있는 컨텍스트들이 모두 실행되어 &lt;strong&gt;스택이 비어있는 상태가되면 태스크 큐에있는 콜백 함수를 콜 스택에 추가&lt;/strong&gt;하고 함수가 실행된다. &lt;strong&gt;태스크 큐에 여러개의 콜백이 있어도 한 번에 한 개의 콜백만 가져온다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4&quot;&gt;https://velog.io/@raejoonee/프로세스와-스레드의-차이&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://academy.dream-coding.com/&quot;&gt;https://academy.dream-coding.com/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/&quot;&gt;사용된 그림 출처&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript란]]></title><description><![CDATA[ECMAScript와 JavaScript ECMAScript는 자바스크립트의 표준 명세인 ECMA-262를 말하며 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 핵심 문법(core syntax…]]></description><link>https://seheeyun.github.io/JavaScript란/</link><guid isPermaLink="false">https://seheeyun.github.io/JavaScript란/</guid><pubDate>Sat, 07 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;ECMAScript와 JavaScript&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ECMAScript는 자바스크립트의 표준 명세인 ECMA-262&lt;/strong&gt;를 말하며 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 핵심 문법(core syntax)을 규정한다. 각 &lt;strong&gt;브라우저 제조사는 ECMAScript를 준수하여 브라우저에 내장되는 자바스크립트 엔진을 구현&lt;/strong&gt;한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ECMA는 European Computer Manufacturer’s Association의 줄임말이며 정보와 통신 시스템을 위한 국제적 표준화 기구이다. ECMAScript는 JavaScript와 같은 스크립트 언어의 표준을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ES6(=ES2015)이란 ECMAScript 6이라는 의미로, ECMA-262 표준의 제6판이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;이들 엔진은 각자 퍼포먼스가 다르고, 지원되는 ECMAScript도 다르다. ECMAScript가 새로운 버전을 발표하면 이에 맞춰서 JavaScript 엔진도 사양을 준수하도록 점진적으로 업데이트를 해준다. 즉, &lt;strong&gt;브라우저마다 ECMAScript를 지원하는 범위가 각자 다르기 때문에, 각 브라우저마다 호환성 문제(Cross Browser Issues)가 발생&lt;/strong&gt;한다. 이러한 문제를 위해 &lt;strong&gt;바벨 babel&lt;/strong&gt;이라는 오픈소스 JavaScript 트랜스 파일러를 사용한다. 바벨은 ES6 사양 기준으로 작성된 코드를 이전 버전과 호환되는 JavaScript버전으로 변환해준다. 주요 브라우저는 ES5까지 지원하기 때문에 바벨이 ES5코드로 변경해주어 호환성 문제를 해결 할 수 있게 해준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker 등을 아우르는 개념이다.&lt;/p&gt;
&lt;p&gt;클라이언트 사이드 Web API는 ECMAScript와는 별도로 World Wide Web Consortium (W3C)에서 별도의 명세로 관리하고 있다.&lt;/p&gt;
&lt;h3&gt;JavaScript의 특징&lt;/h3&gt;
&lt;p&gt;자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 &lt;strong&gt;인터프리터 언어 Interpreter languag&lt;/strong&gt;이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;인터프리터(interpreter)는 고급 언어로 작성된 원시 코드를 한번에 한 줄씩 읽어들여서 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다. 원시 코드를 기계어로 번역하는 컴파일러와 대비된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;대부분의 모던 자바스크립트 엔진(Chrome의 V8, FireFox의 Spidermonkey, Safari의 JavaScriptCore, Microsoft Edge의 Chakra 등)은 &lt;strong&gt;인터프리터와 컴파일러의 장점을 결합&lt;/strong&gt;하여 비교적 처리 속도가 느린 인터프리터의 단점을 해결했다. 인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화한다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 불구하고 보다 빠른 코드의 실행이 가능하다.&lt;/p&gt;
&lt;p&gt;자바스크립트는 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.&lt;/p&gt;
&lt;p&gt;비록 다른 객체지향 언어들과의 차이점에 대한 논쟁들이 있긴 하지만, 자바스크립트는 강력한 객체지향 프로그래밍 능력을 지니고 있다. 간혹 클래스(ES6에서 새롭게 도입되었다), 상속, 정보 은닉을 위한 키워드 private가 없어서 객체지향 언어가 아니라고 오해(자바스크립트는 가장 많은 오해를 받는 언어이다.)하는 경우도 있지만 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 &lt;strong&gt;프로토타입 기반&lt;/strong&gt;의 객체지향 언어이다.&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://sustainable-dev.tistory.com/105&quot;&gt;https://sustainable-dev.tistory.com/105&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://poiemaweb.com/js-introduction&quot;&gt;https://poiemaweb.com/js-introduction&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[브라우저의 동작 원리]]></title><description><![CDATA[브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다.
브라우저는 서버로부터 HTML, CSS, Javascript…]]></description><link>https://seheeyun.github.io/브라우저의 동작 원리/</link><guid isPermaLink="false">https://seheeyun.github.io/브라우저의 동작 원리/</guid><pubDate>Wed, 07 Jul 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다.&lt;br/&gt;
브라우저는 &lt;strong&gt;서버로부터 HTML, CSS, Javascript, 이미지 파일 등을 응답받는다. HTML, CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱(Parsing)되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 표시&lt;/strong&gt;한다.
이 일련의 과정을 &lt;strong&gt;Critical Rendering Path&lt;/strong&gt;라고 한다.&lt;/p&gt;
&lt;h3&gt;Critical Rendering Path&lt;/h3&gt;
&lt;p&gt;주요 렌더링 경로(CRP, Critical Rendering Path)를 최적화하면 최초 페이지 렌더링에 걸리는 시간을 상당히 단축시킬 수 있다. 또한, 주요 렌더링 경로에 대한 이해를 토대로 뛰어난 성능의 대화형 애플리케이션을 빌드할 수도 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTML 마크업을 처리하고 DOM 트리를 빌드&lt;/li&gt;
&lt;li&gt;CSS 마크업을 처리하고 CSSOM 트리를 빌드&lt;/li&gt;
&lt;li&gt;DOM 및 CSSOM을 결합하여 렌더 트리를 형성한다. 이때, 최종적으로 브라우저에 표기될 것들만 선별하여 Render 트리를 만들게 된다(헤드는 표시되지않는 부분이기때문에 포함되지않고, 만약 display: none인 요소가 있다면 이 또한 렌더트리에 포함시키지 않는다)&lt;/li&gt;
&lt;li&gt;layout: 렌더 트리엔 화면에 표시되는 모든 노드의 콘텐츠 및 스타일 정보가 포함되어있고 이 데이터를 기반으로 기기의 &lt;strong&gt;뷰포트&lt;/strong&gt; 내에서 노드의 정확한 위치와 크기를 계산한다.&lt;/li&gt;
&lt;li&gt;Paint: 속성 상태에 따라 레이어(그룹)를 만든다. 변경에 대응하기위해 부분적으로 레이어를 나눠놓고 color, background-color, border-color 등 작업을 진행한다.&lt;/li&gt;
&lt;li&gt;composition: paint에서 만들어진 레이어 순서대로 화면에 그리는 작업을 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;렌더 트리가 수정되어서 layout 단계가 다시 발생하는 경우를 reflow라고 한다. 이는 어플리케이션의 성능을 떨어뜨리는 요인으로 &lt;strong&gt;애니메이션이 발생할 때 reflow가 일어나지 않도록 해야한다.&lt;/strong&gt;
외에도 리소스가 적을수록 당연히 트리를 만드는데 걸리는 시간도 적어진다. 리소스의 크기를 줄이거나 최적화해서 렌더링 성능을 향상시킬 수 있다.&lt;/p&gt;
&lt;h3&gt;async와 defer&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://poiemaweb.com/img/client-server.png&quot; alt=&quot;브라우저 동작 원리&quot;&gt;
자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 &lt;strong&gt;script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.&lt;/strong&gt; 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.&lt;/p&gt;
&lt;p&gt;이처럼 브라우저는 &lt;strong&gt;동기(Synchronous)적으로 HTML, CSS, Javascript을 처리&lt;/strong&gt;한다. 이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다.&lt;/p&gt;
&lt;p&gt;기존에는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;태그 가장 아래에 스크립트를 삽입하여 이 문제를 해결하였으나, 내가 표시해야하는 콘텐츠가 자바스크립트에 의존적인 콘텐츠라면 html을 파싱하고 자바스크립트를 받아오고 실행하기까지의 긴 시간동안 정상적인 콘텐츠를 표시할 수 없다.&lt;/p&gt;
&lt;p&gt;문제를 해결하는 다른 옵션으로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소의 asynd, defer 속성을 사용하는 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;async&lt;/strong&gt;&lt;br/&gt;
async 속성이 있는 스크립트를 만나면 병렬적으로 다운로드한다, 하지만 실행할 때는 html 파싱하던 것을 멈추고 스크립트를 실행시키기 때문에 스크립트가 html 요소를 이용하는 것이라면 요소가 파싱되기도 전에 실행되므로 오류가 발생된다.
그리고 다수의 스크립트를 async로 다운받게 될 경우 작성한 순서와 상관없이 먼저 다운로드되는 것이 먼저 실행된다. 스크립트 순서가 중요하다면 문제가 발생 할 것이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;defer&lt;/strong&gt;&lt;br/&gt;
마찬가지로 스크립트를 병렬적으로 다운로드하지만 async와 다르게 &lt;strong&gt;html 파싱이 끝난 후에 스크립트가 실행&lt;/strong&gt;된다. 순서도 작성한 순서대로 실행된다.&lt;br/&gt;
이 역시 스크립트가 실행되기까지의 시간이 필요하므로 상호작용이 가능한 요소가 준비되지않았다면 그에대한 별도의 표시나 조치가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://poiemaweb.com/js-browser&quot;&gt;https://poiemaweb.com/js-browser&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path?hl=ko&quot;&gt;https://developers.google.com/web/fundamentals/performance/critical-rendering-path?hl=ko&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://academy.dream-coding.com/&quot;&gt;https://academy.dream-coding.com/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://poiemaweb.com/js-browser&quot;&gt;사용된 그림 출처&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[D3.js 사용하기]]></title><description><![CDATA[ui/ux나 비주얼에 관심이 많아서 어떤 라이브러리를 배워볼까 고민하다가 단순한 인터랙션이나 비주얼보단 의미있는, 좀 더 실용적인 시각화 라이브러리를 사용해보고 싶었고 data를 dom 요소로 매핑할 수 있는 D3(Data Driven…]]></description><link>https://seheeyun.github.io/D3.js 사용하기/</link><guid isPermaLink="false">https://seheeyun.github.io/D3.js 사용하기/</guid><pubDate>Wed, 30 Jun 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;ui/ux나 비주얼에 관심이 많아서 어떤 라이브러리를 배워볼까 고민하다가 단순한 인터랙션이나 비주얼보단 의미있는, 좀 더 실용적인 시각화 라이브러리를 사용해보고 싶었고 data를 dom 요소로 매핑할 수 있는 &lt;strong&gt;D3&lt;/strong&gt;(Data Driven Documents)를 선택했다. D3는 차트를 만드는 것 외에도 다양한 활용이 가능하다. &lt;a href=&quot;https://bl.ocks.org/mbostock&quot;&gt;예제들&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;특징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 표준에 가깝다.
D3.js는 웹 표준인 &lt;strong&gt;HTML, SVG, CSS&lt;/strong&gt;를 사용해서 시각화 하기 때문에 최신 브라우저에서의 호환성을 보장한다. 특별한 api를 사용하지않아도 css를 사용해서 스타일링 할 수 있고 d3가 매핑하는 요소는 DOM 요소이기 때문에 브라우저에 내장된 툴로 디버깅하기도 쉽다.&lt;/li&gt;
&lt;li&gt;d3의 메서드들은 요소에 메서드를 수행하고 해당 요소를 반환한다. d3는 제이쿼리와 유사한 방식(’.’을 사용하여 연결)을 사용하여 메서드들을 연결하는 &lt;strong&gt;Method Chaining&lt;/strong&gt;를 사용하고 이는 코드를 읽기쉽고 간결하게 만들어준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;핵심 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;d3.select(), d3.selectAll()&lt;/strong&gt;: 최상위 레벨의 메서드로, 요소를 선택한다. 이 메서드들은 셀렉터 문자열을 인자로 받는데, 지정한 문자열과 일치하는 요소가 없다면 빈 선택물을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;selection.data()&lt;/strong&gt;: 선택물에 data 배열을 연결해준다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;selection.enter()&lt;/strong&gt;: 연결해준 data에 해당 선택물이 부족한 수 만큼 플레이스 홀더 역할을 하는 선택물을 반환한다. enter는 부족한 선택물의 참조만을 반환하므로 append()를 사용해서 노드를 추가해야한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;selection.exit()&lt;/strong&gt;: data의 수보다 현재 선택물의 요소가 많은 경우 그 남는 선택물을 반환한다. 보통 남는 선택물은 remove()를 사용해서 지워준다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;selection.attr(name[, value])&lt;/strong&gt;: value 인자를 지정하여 선택한 모든 요소에 지정한 속성명과 값을 부여한다. value가 상수이면 모든 요소에 같은 속성값이 주어지지만 value가 함수이면 각 요소별로 적용된다.
이 함수는 전달인자로 datum d와 인덱스 i가 넘어오고 this는 현재 DOM 요소다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;d3는 동적인 그래프를 만들 수 있는데, 기존에는 위의 메서드들을 활용한 General Update Pattern을 통해 데이터를 바인딩시키고 부족한 만큼 요소를 반환해서 추가해주고 병합시키는 방법을 사용했지만 새로 추가된 &lt;strong&gt;selection.join()&lt;/strong&gt; 메서드를 사용하여 위의 메서드들을 일일이 작성하지않고 한개의 메서드로 그래프를 업데이트 시킬 수 있게되었다.&lt;/p&gt;
&lt;p&gt;join()을 이용해서 만든 요소에 속성을 지정하려면, 원래의 방식(General Update Pattern)처럼 enter나 update 뒤에 attr()를 추가하지않고 join() 뒤에 attr()를 붙여서 지정해준다. 이유는 join()이 엔터링되고 업데이트된 요소를 모두 반환하기때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;useEffect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; svg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;svgRef&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;current&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  svg
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;selectAll&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;circle&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;token parameter&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; enter&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;circle&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token parameter&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; update&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;class&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;updated&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token parameter&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; exit&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;cx&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;cy&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;stroke&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;join() 안에 exit.remove는 사실 디폴트로 적용되기때문에 따로 지정해줄 필요없다. 단, 애니메이션을 이용하기위에 따로 삭제해줘야하는 경우 적용해줄 수 있다.
update 콜백함수 또한 같은 이유로 지정해줄 필요가 없다.&lt;/p&gt;
&lt;p&gt;enter.append도 아래와 같이 간결하게 적어주면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;circle&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;결론적으로 위와 같이 심플한 한줄의 코드가 첫번째 로직과 같다는 것이다. 그것이 join()의 기능이다.&lt;/p&gt;
&lt;p&gt;이 외에 d3는 다양한 scale 함수나 축, 지도 등을 만들 수 있는 메서드들을 지원해줘서 복잡한 계산없이 그래프들을 구현할 수 있다.&lt;/p&gt;
&lt;h3&gt;React와 함께&lt;/h3&gt;
&lt;p&gt;d3가 대부분을 처리하고 react는 step back해서 svg 요소를 제공하는 방식을 사용했다.
활용하기에따라 d3는 단순히 계산을 하고 계산된 값을 react가 렌더링하게 할 수도 있다.&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/d3/d3/wiki&quot;&gt;https://github.com/d3/d3/wiki&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://github.com/zziuni/d3/wiki/API-Reference&quot;&gt;https://github.com/zziuni/d3/wiki/API-Reference&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://mynameisdabin.tistory.com/15?category=786517&quot;&gt;https://mynameisdabin.tistory.com/15?category=786517&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://velog.io/@smooth97/-Data-Visualizing-D3.js-%EB%9E%80&quot;&gt;https://velog.io/@smooth97/-Data-Visualizing-D3.js-란&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://youtu.be/9uEmNgHzPhQ&quot;&gt;https://youtu.be/9uEmNgHzPhQ&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[210531]]></title><description><![CDATA[Today React Router 다른 페이지에 props 넘겨주기 어떤 페이지 컴포넌트에서 다른 페이지로 넘어갈때, 컴포넌트가 가지고있는 state를 props로 전달 해줘야하는 경우 Link나 useHistory hook…]]></description><link>https://seheeyun.github.io/210531/</link><guid isPermaLink="false">https://seheeyun.github.io/210531/</guid><pubDate>Mon, 31 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Today&lt;/h2&gt;
&lt;h3&gt;React Router 다른 페이지에 props 넘겨주기&lt;/h3&gt;
&lt;p&gt;어떤 페이지 컴포넌트에서 다른 페이지로 넘어갈때, 컴포넌트가 가지고있는 state를 props로 전달 해줘야하는 경우&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Link나 useHistory hook을 이용해서 객체를 전달해주고&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Link
  to&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    pathname&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;/courses&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    search&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;?sort=name&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    hash&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;#the-hash&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    state&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; fromDashboard&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;

&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;history&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  pathname&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;/courses&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  state&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;fromDashboard&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;useLocation hook으로 해당 페이지의 정보를 불러온다&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; location &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useLocation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;location&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;컴포넌트를 감싸는 Route 태그의 부모 요소인 BrowserRouter, Switch에 의해서 컴포넌트의 defaultProps 에는 history 객체가 들어가게 되고, 이 history 객체를 이용하여 리액트 어플리케이션 내에서 라우팅이 가능하다.&lt;br&gt;
react router hooks를 사용하면 각 객체에 쉽게 접근할 수 있다.&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://reactrouter.com/web/api/Link&quot;&gt;https://reactrouter.com/web/api/Link&lt;/a&gt;
&lt;a href=&quot;https://pythonq.com/so/reactjs/110304&quot;&gt;https://pythonq.com/so/reactjs/110304&lt;/a&gt;
&lt;a href=&quot;https://velog.io/@dhlee91/this.props.history.push%EB%A1%9C-props-%EB%84%98%EA%B2%A8%EC%A3%BC%EA%B8%B0&quot;&gt;https://velog.io/@dhlee91/this.props.history.push로-props-넘겨주기&lt;/a&gt;
&lt;a href=&quot;https://velog.io/@yiyb0603/React-Router-dom%EC%9D%98-%EC%9C%A0%EC%9A%A9%ED%95%9C-hooks%EB%93%A4&quot;&gt;https://velog.io/@yiyb0603/React-Router-dom의-유용한-hooks들&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;textarea 자동 높이 증가&lt;/h3&gt;
&lt;p&gt;처음엔 간단하게 scrollHeight에 따라 textarea의 height값이 늘어나는 로직을 작성했는데 layout shift가 계속해서 발생하고 화면에 떨림이 생겨서 다른 방법을 검색해보았다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/auto-growing-inputs-textareas/&quot;&gt;https://css-tricks.com/auto-growing-inputs-textareas/&lt;/a&gt;&lt;br&gt;
inline-grid, dataset 이용한 방법. enter를 입력해야지만 height값이 늘어나서 사용성 떨어짐&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Andarist/react-textarea-autosize#readme&quot;&gt;https://github.com/Andarist/react-textarea-autosize#readme&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://medium.com/@lucasalgus/creating-a-custom-auto-resize-textarea-component-for-your-react-web-application-6959c0ad68bc&quot;&gt;https://medium.com/@lucasalgus/creating-a-custom-auto-resize-textarea-component-for-your-react-web-application-6959c0ad68bc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;직접 만들거나 라이브러리를 사용할 수도 있다.&lt;/p&gt;
&lt;p&gt;최종적으론 프로젝트에 적용되있는 metarial ui에 &lt;a href=&quot;https://material-ui.com/api/textarea-autosize/&quot;&gt;TextareaAutosize API&lt;/a&gt;가 있어서 이것을 사용했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[210530]]></title><description><![CDATA[Today window.matchMedia() 컴포넌트의 크기를 js를 이용해서 동적으로 계산해주고 있을때, viewport크기에 따라 다른 수치를 주기위해 matchMedia 메서드 사용 Window.matchMedia…]]></description><link>https://seheeyun.github.io/210530/</link><guid isPermaLink="false">https://seheeyun.github.io/210530/</guid><pubDate>Sun, 30 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Today&lt;/h2&gt;
&lt;h3&gt;window.matchMedia()&lt;/h3&gt;
&lt;p&gt;컴포넌트의 크기를 js를 이용해서 동적으로 계산해주고 있을때, viewport크기에 따라 다른 수치를 주기위해 matchMedia 메서드 사용&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Window.matchMedia()&lt;/strong&gt; 메서드는 주어진 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/CSS/Media_Queries/Using_media_queries&quot;&gt;미디어 쿼리&lt;/a&gt; 문자열의 분석 결과를 나타내는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&quot;&gt;MediaQueryList&lt;/a&gt; 객체를 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MediaQueryList&lt;/strong&gt;는 특정 document에 적용된 media query에 관한 정보를 포함하는 객체이다. MediaQueryLIst는 matches, media 두 프로퍼티를 포함한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MediaQueryList.matches&lt;br&gt;
해당 document 가 주어진 미디어 쿼리를 만족하는지 여부로, boolean 값이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MediaQueryList.media&lt;br&gt;
주어진 미디어 쿼리를 string 으로 serialize 한 값이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;직렬화: 데이터나 오브젝트를 동일하거나 다른 컴퓨터 환경에 저장하고 나중에 재구성할 수 있는 포맷으로 변환하는 과정이다. 반대로, 일련의 바이트로부터 데이터 구조를 추출하는 일은 역직렬화 deserialization)이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MediaQueryList는 미디어 쿼리에 관한 정보를 담고 있기 때문에 미디어 쿼리가 변경되면 change 이벤트를 발생시킬 수 있다. 이 change 이벤트를 핸들링하는 이벤틑 리스너를 추가해주면 주어진 미디어 쿼리를 충족하는지 watch 할 수 있고, 결과적으로 programmatic 하게 미디어 쿼리를 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;프로젝트에 &lt;a href=&quot;https://ko.reactjs.org/docs/hooks-custom.html&quot;&gt;custom hook&lt;/a&gt;으로 만들어서 적용했다.&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://eunsukim.me/posts/how-to-use-media-query-with-javascript-matchmedia&quot;&gt;https://eunsukim.me/posts/how-to-use-media-query-with-javascript-matchmedia&lt;/a&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/Window/matchMedia&quot;&gt;https://developer.mozilla.org/ko/docs/Web/API/Window/matchMedia&lt;/a&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&lt;/a&gt;
&lt;a href=&quot;https://www.netlify.com/blog/2020/12/05/building-a-custom-react-media-query-hook-for-more-responsive-apps/&quot;&gt;https://www.netlify.com/blog/2020/12/05/building-a-custom-react-media-query-hook-for-more-responsive-apps/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[210528]]></title><description><![CDATA[Today SQL, noSQL 스키마(Schema)  컴퓨터 과학에서 데이터베이스 스키마(database schema…]]></description><link>https://seheeyun.github.io/210528/</link><guid isPermaLink="false">https://seheeyun.github.io/210528/</guid><pubDate>Fri, 28 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Today&lt;/h2&gt;
&lt;h3&gt;SQL, noSQL&lt;/h3&gt;
&lt;h4&gt;스키마(Schema) &lt;/h4&gt;
&lt;p&gt;컴퓨터 과학에서 데이터베이스 스키마(database schema)는 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조이다. 데이터베이스 관리 시스템(DBMS)이 주어진 설정에 따라 데이터베이스 스키마를 생성하며, 데이터베이스 사용자가 자료를 저장, 조회, 삭제, 변경할 때 DBMS는 자신이 생성한 데이터베이스 스키마를 참조하여 명령을 수행한다.&lt;/p&gt;
&lt;p&gt;데이터베이스의 구조와 제약조건에 관해 전반적인 명세를 기술한 것
개체의 특성을 나타내는 속성(Attribute)과 속성들의 집합으로 이루어진 개체(Entity), 개체 사이에 존재하는 관계(Relation)에 대한 정의와 이들이 유지해야 할 제약조건들을 기술한 것&lt;/p&gt;
&lt;p&gt;스키마는 3개의 구조로 나눠진다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;개념스키마(Conceptual Schema)&lt;/strong&gt;&lt;br&gt;
조직체 전체를 관장하는 입장에서 DB를 정의한 것
- 데이터 베이스의 전체적인 논리적 구조&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;내부스키마(Internal Schema)&lt;/strong&gt;&lt;br&gt;
물리적인 저장장치 입장에서 DB가 저장되는 방법을 기술한 것
- 데이터 베이스의 물리적 저장구조를 정의&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;외부스키마(External Schema, 서브 스키마)&lt;/strong&gt;&lt;br&gt;
사용자나 응용 프로그래머가 개인의 입장에서 필요한 데이터베이스의 논리적 구조를 정의
- 실세계에 존재하는 데이터들을 어떤 형식, 구조, 배치 화면을 통해 사용자에게 보여줄 것인가&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;SQL(관계형 데이터베이스)&lt;/h4&gt;
&lt;p&gt;SQL(Structured Query Language)은 관계형 데이터베이스 관리 시스템의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이다. 관계형 데이터베이스 관리 시스템((RDBMS : relational database management system))에서 자료의 검색과 관리, 데이터베이스 스키마 생성과 수정, 데이터베이스 객체 접근 조정 관리를 위해 고안되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터는 정해진(엄격한) 데이터 스키마(= structure)를 따라 데이터베이스 테이블에 저장 &gt; 명확하게 정의 된 스키마, 데이터 무결성 보장&lt;/li&gt;
&lt;li&gt;데이터는 관계를 통해서 연결된 여러개의 테이블에 분산. 데이터들을 여러개의 테이블에 나누어서, 데이터들의 중복을 피할 수 있다.&lt;/li&gt;
&lt;li&gt;관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있다.&lt;/li&gt;
&lt;li&gt;수직적 확장(Vertical Scaling)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;NoSQL(비관계형 데이터베이스)&lt;/h4&gt;
&lt;p&gt;NoSQL 데이터베이스는 전통적인 관계형 데이터베이스 보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공한다. 이러한 접근에 대한 동기에는 디자인의 단순화, 수평적 확장성, 세세한 통제를 포함한다. NoSQL 데이터베이스는 단순 검색 및 추가 작업을 위한 매우 최적화된 키 값 저장 공간으로, 레이턴시와 스루풋과 관련하여 상당한 성능 이익을 내는 것이 목적이다. NoSQL 데이터베이스는 빅데이터와 실시간 웹 애플리케이션의 상업적 이용에 널리 쓰인다. 또, NoSQL 시스템은 SQL 계열 쿼리 언어를 사용할 수 있다는 사실을 강조한다는 면에서 “Not only SQL”로 불리기도 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스키마 없음 &gt; 유연, 언제든지 저장된 데이터를 조정하고 새로운 “필드”를 추가 할 수 있다.&lt;/li&gt;
&lt;li&gt;관계형 모델을 사용하지 않으며 테이블 간 연결해서 조회할 수 있는 조인 기능이 없음&lt;/li&gt;
&lt;li&gt;조인을 하지않고 관련 데이터를 동일한 컬렉션에 넣기때문에 빠르지만 데이터가 중복 될 수 있다.&lt;/li&gt;
&lt;li&gt;데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함. (SQL은 중복된 데이터가 없기 때문에 한번만 수행)&lt;/li&gt;
&lt;li&gt;데이터는 애플리케이션이 필요로 하는 형식으로 저장, 데이터를 읽어오는 속도가 빠르다.&lt;/li&gt;
&lt;li&gt;수평적 확장(Horizontal Scaling)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;SQL은 언제 사용하는 것이 좋을까?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;관계를 맺고 있는 데이터가 자주 변경(수정)되는 애플리케이션일 경우 (NoSQL에서라면 여러 컬렉션을 모두 수정해줘야 한다.)&lt;/li&gt;
&lt;li&gt;변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;NoSQL은 언제 사용하는 것이 좋을까?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;정확한 데이터 구조를 알 수 없거나 변경 / 확장 될 수 있는 경우&lt;/li&gt;
&lt;li&gt;읽기(read)처리를 자주하지만, 데이터를 자주 변경(update)하지 않는 경우 (즉, 한번의 변경으로 수십 개의 문서를 업데이트 할 필요가 없는 경우)&lt;/li&gt;
&lt;li&gt;데이터베이스를 수평으로 확장해야 하는 경우 ( 즉, 막대한 양의 데이터를 다뤄야 하는 경우)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://jwprogramming.tistory.com/47&quot;&gt;https://jwprogramming.tistory.com/47&lt;/a&gt;
&lt;a href=&quot;https://jwprogramming.tistory.com/70?category=680195&quot;&gt;https://jwprogramming.tistory.com/70?category=680195&lt;/a&gt;
&lt;a href=&quot;https://siyoon210.tistory.com/130&quot;&gt;https://siyoon210.tistory.com/130&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Material UI Icons&lt;/h3&gt;
&lt;p&gt;원래 fontawesome을 사용하고 있었는데, free 아이콘 종류가 한정적이라 종류도 많고 다양한 스타일(Filled, Outlined, Rounded, Two tone, Sharp)을 지원해주는 Material UI을 사용해 보았다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;yarn add @material&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;ui&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;icons&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;core를 사용하지않고 있다면 core도 함께 설치&lt;/p&gt;
&lt;p&gt;사용법은 간단하다. &lt;a href=&quot;https://material-ui.com/components/material-icons/&quot;&gt;Material Icons&lt;/a&gt;에서 원하는 아이콘을 선택하고 해당 아이콘 컴포넌트를 import해주면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeIcon color&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;secondary&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeIcon color&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;action&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeIcon color&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;disabled&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeIcon style&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; green&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;

&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeIcon fontSize&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;small&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeIcon fontSize&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;large&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;HomeIcon style&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; fontSize&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;컴포넌트 속성을 이용해서 style을 지정해 줄 수 있다.&lt;/p&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daleseo.com/material-ui-icons/&quot;&gt;https://www.daleseo.com/material-ui-icons/&lt;/a&gt;
&lt;a href=&quot;https://material-ui.com/components/icons/&quot;&gt;https://material-ui.com/components/icons/&lt;/a&gt;
&lt;a href=&quot;https://material-ui.com/guides/minimizing-bundle-size/#option-2&quot;&gt;https://material-ui.com/guides/minimizing-bundle-size/#option-2&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[210525]]></title><description><![CDATA[Today gitignore 캐시 삭제하기 .gitignore에 파일 추가 했는데 적용되지 않을 때 위의 명령어로 캐시 삭제해주고 add, commit하면 적용된다 도움 받은 글 https://webruden.tistory.com/134]]></description><link>https://seheeyun.github.io/210525/</link><guid isPermaLink="false">https://seheeyun.github.io/210525/</guid><pubDate>Tue, 25 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Today&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gitignore 캐시 삭제하기&lt;/p&gt;
&lt;p&gt;.gitignore에 파일 추가 했는데 적용되지 않을 때&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;git rm -r --cached .&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 명령어로 캐시 삭제해주고 add, commit하면 적용된다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://webruden.tistory.com/134&quot;&gt;https://webruden.tistory.com/134&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[210524]]></title><description><![CDATA[Today DNS, CDN 개념 정리 firebase 공식 문서 읽어보고 실습 card maker 프로젝트에 Firebase Authentication 적용
firebase 인증 추가해주고 ui는 따로 만들지않고 firebaseui…]]></description><link>https://seheeyun.github.io/210524/</link><guid isPermaLink="false">https://seheeyun.github.io/210524/</guid><pubDate>Mon, 24 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Today&lt;/h2&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; checked disabled&gt; DNS, CDN 개념 정리&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; checked disabled&gt; firebase 공식 문서 읽어보고 실습&lt;/p&gt;
&lt;p&gt;card maker 프로젝트에 Firebase Authentication 적용&lt;br&gt;
firebase 인증 추가해주고 ui는 따로 만들지않고 firebaseui 적용&lt;br&gt;
컴포넌트에서 start 메소드를 사용 할 수있게 export 해줌&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;startFirebaseUI&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;elementId&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
ui&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;elementId&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  signInOptions&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;firebase&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;auth&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;EmailAuthProvider&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;PROVIDER_ID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// Other config options...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; startFirebaseUI&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://firebase.google.com/docs/web/setup?hl=ko&amp;#x26;sdk_version=v8&quot;&gt;https://firebase.google.com/docs/web/setup?hl=ko&amp;#x26;sdk_version=v8&lt;/a&gt;
&lt;a href=&quot;https://firebase.google.com/docs/auth/web/firebaseui?hl=ko&quot;&gt;https://firebase.google.com/docs/auth/web/firebaseui?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://firebaseopensource.com/projects/firebase/firebaseui-web/&quot;&gt;https://firebaseopensource.com/projects/firebase/firebaseui-web/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tomorrow&lt;/h2&gt;
&lt;ul&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 모던 JavaScript 튜토리얼 (코드품질부터) 읽기&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; 프로그래머스 코테 입문&lt;/li&gt;
&lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; disabled&gt; card maker 프로젝트 header, main, login ui 만들기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[210523]]></title><description><![CDATA[내가 이루고픈 큰 목표를 위해선 작은 목표들과 그에 대한 실천이 선행되어야한다.
목표들을 달성하는데 동기부여를 하고 그 날 공부한 것을 되돌아보기위해 TIL…]]></description><link>https://seheeyun.github.io/210523/</link><guid isPermaLink="false">https://seheeyun.github.io/210523/</guid><pubDate>Sun, 23 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;내가 이루고픈 큰 목표를 위해선 작은 목표들과 그에 대한 실천이 선행되어야한다.
목표들을 달성하는데 동기부여를 하고 그 날 공부한 것을 되돌아보기위해 TIL를 작성해보자!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;오늘 한 일과 배운것을 기록하면서 애매했던 개념들을 확실히 정리한다.&lt;/li&gt;
&lt;li&gt;간단하게 하루 동안 느낀점이나 생각을 정리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Today&lt;/h2&gt;
&lt;h3&gt;GatsbyJS로 블로그 구현&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/docs/&quot;&gt;https://www.gatsbyjs.com/docs/&lt;/a&gt; 튜토리얼 &amp;#x26; 가이드&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공식 문서가 잘 정리돼있고 &lt;a href=&quot;https://www.gatsbyjs.com/starters/?v=2&quot;&gt;Starters&lt;/a&gt;에서 이미 만들어져 있는 템플릿을 활용할 수 있어서 비교적 쉽게 구현할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://graphql.org/&quot;&gt;GraphQL&lt;/a&gt;은 처음 활용해 보는데, &lt;a href=&quot;https://www.electronjs.org/apps/graphiql&quot;&gt;GraphiQL&lt;/a&gt;를 이용해서 받아올 데이터를 미리 테스트해볼 수 있어서 접근성이 좋은것같다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gatsby는 배포하기전 &lt;code class=&quot;language-text&quot;&gt;빌드&lt;/code&gt; 시점에 소스들을 html로 렌더링하기때문에 &lt;code class=&quot;language-text&quot;&gt;배포&lt;/code&gt; 시 소스들이 변환되어져있다. 만들어둔 소스코드을 유지하기 위해 브랜치를 나눠서 사용한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;빌드&lt;/strong&gt;: 소스 코드 파일을 컴퓨터나 휴대폰에서 실행할 수 있는 독립 소프트웨어 가공물로 변환하는 과정을 말하거나 그에 대한 결과물을 일컫는다. &lt;br&gt; &lt;strong&gt;배포&lt;/strong&gt;: 빌드가 완료된 실행파일을 사용자가 접근할 수 있는 환경에 배치하는 일&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;키워드를 이용해 글을 찾을 수 있도록 태그 기능을 추가했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;도움 받은 글&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@magnoliarfsit/TIL-Session-Gatsby%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0&quot;&gt;https://velog.io/@magnoliarfsit/TIL-Session-Gatsby로-블로그-만들기&lt;/a&gt;
&lt;a href=&quot;https://www.gatsbyjs.com/docs/adding-tags-and-categories-to-blog-posts/&quot;&gt;https://www.gatsbyjs.com/docs/adding-tags-and-categories-to-blog-posts/&lt;/a&gt;
&lt;a href=&quot;https://wayhome25.github.io/&quot;&gt;https://wayhome25.github.io/&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>