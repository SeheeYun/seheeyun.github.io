{"componentChunkName":"component---src-templates-blog-post-js","path":"/TypeScrpit + OOP/","result":{"data":{"site":{"siteMetadata":{"title":"Sehee Blog"}},"markdownRemark":{"id":"2b66e210-d50d-51bb-beee-a147ddff8071","excerpt":"TypeScript 타입스크립트는 Microsoft에서 개발하고 유지/관리하는 오픈 소스 프로젝트로서, 자바스크립트로 컴파일되는 superset of JavaScript 이기 때문에 자바스크립트가 동작하는 모든 곳에서 대체하여 사용할 수 있는 언어이다. 자바스크립트는 C나 Java…","html":"<h3>TypeScript</h3>\n<p>타입스크립트는 Microsoft에서 개발하고 유지/관리하는 오픈 소스 프로젝트로서, 자바스크립트로 컴파일되는 superset of JavaScript 이기 때문에 자바스크립트가 동작하는 모든 곳에서 대체하여 사용할 수 있는 언어이다.</p>\n<p>자바스크립트는 C나 Java와 같은 C-family 언어와는 구별되는 아래와 같은 특성이 있는데</p>\n<ul>\n<li>동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely typed) 언어</li>\n<li>Prototype-based Object Oriented Language</li>\n</ul>\n<p>자바스크립트는 런타임에 실시간으로 타입이 결정되는 동적 언어이기때문에 런타임 환경에서 예상치 못한 에러가 발생할 수 있다. 타입스크립트는 정적 타이핑을 지원하고 이는 사전에 타입을 명시적으로 선언하도록하며 잘못된 값을 할당할 경우 컴파일러를 통해 대부분의 에러를 확인 할 수 있게한다.</p>\n<p>또한 타입스크립트는 interface, generic 등을 지원하여 클래스를 베이스로하는 다른 언어들과같이 더욱 강력한 객체 지향 프로그래밍을 가능하게 한다.</p>\n<h3>객체 지향 프로그래밍(Object-Oriented Programming)</h3>\n<blockquote>\n<p>객체 지향 프로그래밍은 컴퓨터 프로그래밍의 패러다임 중 하나로, 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 “객체”들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다. 프로그램을 유연하고 변경이 쉽게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점이 있다.</p>\n</blockquote>\n<h4>Encapsulation 캡슐화</h4>\n<p>서로 관련있는 데이터와 메서드를 한 오브젝트안에 담아두고 외부에서 보일 필요가 없는 데이터를 잘 숨겨놓음으로써 캡슐화 하는것.</p>\n<p>외부에서 내부의 상태를 직접 조작하게 하는 것은 위험하기때문에 private 키워드와 같은 접근제어자로 은닉화해서 외부에서 접근 할 수 없도록 해준다.</p>\n<ul>\n<li><strong>public</strong><br/>\n클래스로 만들어준 오브젝트에는 클래스의 멤버변수들이 인스턴스화하여 생성되어있다. 아무런 키워드가 없다면 public 으로 외부에서 바로 접근이 가능하다.</li>\n<li><strong>private</strong><br/>\n클래스의 내부에서만 사용되며 외부로 노출되지 않는다.</li>\n<li><strong>protected</strong><br/>\n외부에서 접근할 수 없고, 자신을 상속하는 자식 클래스에서만 접근이 가능하다.</li>\n</ul>\n<p>생성자 함수(constructor) 자체를 private으로 만들면 클래스를 생성자 함수로 생성할 수 없어지기때문에 메서드를 static 으로 제공해서 클래스에 메서드만 사용해서 오브젝트를 생성하게 할 수 도있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">CoffeeMachineImple</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 안됨</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token function\">makeMachine</span><span class=\"token punctuation\">(</span>coffeeBeans<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> CoffeeMachineImple <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CoffeeMachineImple</span><span class=\"token punctuation\">(</span>coffeeBeans<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> machine <span class=\"token operator\">=</span> CoffeeMachineImple<span class=\"token punctuation\">.</span><span class=\"token function\">makeMachine</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p><strong>static</strong><br/>\n클래스의 멤버변수는 클래스를 인스턴스화 했을 때 생성, 바뀌지 않는 값이되고 해당 클래스로 생성한 모든 인스턴스마다 저 값이 중복적으로 생성되기때문에 메모리 낭비가 된다. 이럴 경우 변수앞에 <strong>static을 붙여줘서 클래스 레벨로 지정</strong>해 줄 수 있다. static을 붙이지 않으면 인스턴스 레벨이다.</p>\n<p>위와 같이 클래스 레벨로 만든경우 이 클래스로 생성된 인스턴스가 아닌 클래스 자체의 데이터이기 때문에 this.가 아닌 클래스 이름 자체를 지정해서 접근한다.</p>\n</li>\n</ul>\n<h4>Abstraction 추상화</h4>\n<p>내부의 복잡한 기능은 외부에 보이지않게 하고 외부에서 보이는 인터페이스(함수)만을 통해 내부 기능을 이해하지 않아도 사용할 수 있도록 하는 것.</p>\n<p>캡슐화와 달리 ‘건드리면 안되는 것은 숨기고, 건드려도 되는 것은 노출한다’가 아니라, 복잡한 로직들을 외부에서 어떻게 사용하게 할것인가를 고민하는 단계로 <strong>객체들에 공통적으로 존재하는 메소드와 속성들을 뽑아서(추출), 인터페이스나 다른 부모 클래스의 형태로 새롭게 만드는 것</strong>을 의미한다.</p>\n<p>추상화의 가장 큰 장점은 같은 인터페이스를 구현하는 클래스들은 각자 저마다 다른 방식을 구현하더라도, 사용자는 인터페이스에 정의된 함수 하나로 단순하게 기능을 사용 할 수 있는 것이다.</p>\n<h4>Inheritance 상속</h4>\n<p>상속을 이용해서 클래스를 <strong>재사용</strong> 할 수 있다.</p>\n<p>상속하는 자식 클래스는 부모 클래스라고 말할 수 있는데 예로 animal에 상속을 사용해서 만든 강아지, 고양이는 animal이다. IS-A, is a 관계라고도 말한다.</p>\n<p>상속을 하게 되면 기본적으로는 부모 클래스에서 가지고 있는 모든 멤버 변수(속성), 함수(행동) 들에 대해서 자식 클래스가 모두 다 가지게 되고, 자식 클래스의 this로 접근 할 수 있다.</p>\n<p>단, 생성자나 함수에 한해서만 자식 클래스가 상속을 하면서 변경을 할 수 있게 되고(<strong>method overriding</strong>) 이때 <strong>자식에서 재정의된 함수를 호출하고 싶다면 this</strong>를, <strong>기존의 부모 클래스에서 작성된 함수(또는 생성자)를 호출하고 싶다면 super</strong>를 써야 한다.</p>\n<ul>\n<li>super<br/>\nsuper 키워드를 사용하면 부모 클래스에 접근 할 수 있다. 자식 클래스에서 생성자 함수를 사용하고싶다면 생성자 함수 내부에서 super를 호출해야한다.\n그리고 부모클래스의 생성자 함수에 필요한 인자가 있다면 자식 클래스에서도 인자를 받아서 super의 인자로 부모클래스에 전달해주어야한다.</li>\n</ul>\n<p>타입스크립트는 <strong>상속으로 서로다른 두 클래스를 상속하는 것(합치는 것)이 불가능하며, 부모 클래스의 행동을 수정하게 될 경우 상속하는 모든 자식 클래스에도 영향을 미치는 단점이 있기 때문에 상속의 깊이가 깊어질수록 관계가 복잡해진다.</strong></p>\n<h4>Polymorphism 다형성</h4>\n<p>하나의 인터페이스나 부모 클래스를 상속한 자식 클래스들은 인터페이스와 부모 클래스에 있는 함수들을 각자 다른 방식으로 다양한 형태로 구성할 수 있다는 것이다.</p>\n<p>다르게 말하면 부모 클래스를 상속해서 만들어진 자식 클래스들의 다양한 형태를 신경쓸 필요없이 공통된 (부모 클래스의)함수를 호출할 수 있는 것.</p>\n<h4>Composition</h4>\n<p>위에서 설명한 상속의 단점들을 고려하여 확장성있고 재사용성있는 코드를 작성해야할 때, Composition을 사용한다.</p>\n<p>생성자 함수의 인자에 타입을 지정하여 <strong>의존성 주입(Defendency Injection)</strong>을 해준다. 이때, <strong>클래스끼리의 의사소통은 클래스 자신을 직접적으로 노출하지않고 interface를 통해서 의사소통하는 것이 디커플링의 원칙</strong>이다.</p>\n<p>인터페이스로 인자의 타입을 지정해준 뒤 그 인터페이스를 구현하는 다양한 클래스를 만듦으로써 인자로 그 클래스들을 전달해주면 되니까 상속을 전혀 사용하지않고 다양한 형태의 오브젝트를 원하는 대로 조립해서 만들 수 있게된다.</p>\n<h4>interface</h4>\n<p>인터페이스는 일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용할 수 있다. 인터페이스는 여러가지 타입을 갖는 프로퍼티로 이루어진 새로운 타입을 정의하는 것과 유사하다. <strong>인터페이스는 자신을 구현하는 클래스에 인터페이스에 선언된 프로퍼티 또는 메소드의 구현을 강제하여 일관성을 유지</strong>할 수 있게한다.</p>\n<p>프로퍼티와 메소드를 가질 수 있다는 점에서 클래스와 유사하나 직접 인스턴스를 생성할 수 없고 모든 메소드는 추상 메소드이다.</p>\n<p>인터페이스는 extends 키워드를 사용하여 확장할 수 있다. 인터페이스 또는 클래스를 상속받거나 복수의 인터페이스를 상속받을 수도 있다.\n클래스를 상속했을 떈, 클래스의 모든 멤버(public, protected, private)가 상속되지만 구현까지 상속하지는 않는다.</p>\n<h4>도움 받은 글</h4>\n<p><a href=\"https://poiemaweb.com/typescript-introduction\">https://poiemaweb.com/typescript-introduction</a><br/>\n<a href=\"https://academy.dream-coding.com/\">https://academy.dream-coding.com/</a></p>","frontmatter":{"title":"TypeScrpit + OOP","date":"January 21, 2022","description":null}},"previous":{"fields":{"slug":"/React State의 불변성/"},"frontmatter":{"title":"React State의 불변성"}},"next":null},"pageContext":{"id":"2b66e210-d50d-51bb-beee-a147ddff8071","previousPostId":"6ccaa6d2-4d59-5c9e-b8ae-ac9b75cd1b0d","nextPostId":null}},"staticQueryHashes":["230163734","3589320610"]}